
## 一.相同的树
[相同的树](https://leetcode.cn/problems/same-tree/description/)
### 题目描述
- 给定两个二叉树p和q，编写函数判断两个树是否相同

### 思路
- 两个二叉树相同，即两个二叉树相应节点的值都相同
- 可以采用递归的策略，如果当前两个树当前节点相同并且两个树的左子树和右子树分别相同，则两个二叉树相同
- 边界条件: 
    - 当前两个节点都是空指针: `return true;`
    - 当前两个节点都不是空指针:`return p->val==q->val&&isSame(p->left,q->left)&&isSame(p->right,q->right);`
    - 其他(一个为空，另一个不是空):`return fasle;`

### 变式
[对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
- 对称二叉树:给定一个二叉树root节点，判断是否为轴对称
    - 只需判断`root->left`和`root->right`两棵子树是否为轴对称
    - 观察两颗子树轴对称只需当前节点相同，并且一棵树的左(右)子树等于右(左)子树.
---
## 二.二叉树的最大深度
[二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)
### 题目描述
- 给定一个二叉树root，返回其最大深度

### 思路
- 可以采用递归的策略，先求出左右子树的最大深度h，该子树的最大深度为h+1
- 边界条件:
    - 当前节点为空:`return 0;`
    - 当前节点不为空:`return max(maxDepth(root->left),maxDepth(root->right))+1;`
---
## 三.平衡二叉树
[平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/description/)
### 题目描述
- 给定一个二叉树，判定其是否为平衡二叉树(树的所有节点的左右子树的高度相差不超过1)

### 思路

#### 方法一:自顶向底
- 定义一个height函数，一个平衡二叉树满足：左右子树分别是平衡二叉树并且左右子树的高度相差不超过1,即`return abs(height(root->left)-height(root->right))<=1&&isBalanced(root->left)&&isBalanced(root->right);`

- **缺点**：距离叶子节点较近的节点遍历次数较多，复杂度较高

- **时间复杂度**：平均情况下二叉树为满二叉树,`T(n)=2T(n/2)+O(n)`,解方程时间复杂度为`O(n)`

#### 方法二：自底向顶

- 本题要始终维护两个值，子树的高度和子树是否为平衡二叉树
- 维护高度较为容易，直接返回左右子树高度最大值加1
- 维护左右子树是否为平衡二叉树:
    - 首先想到可以传入引用变量ok，每次更新`ok=ok&&(abs(h1-h2)<=1);`，
    **易错点**：在叶子节点时，`ok=ok&&true`。因为当一颗树的左子树不是平衡二叉树时,直接写`ok=true`会误判这棵树为平衡二叉树
    - 另外，还可以通过返回值来维护左右子树是否为平衡二叉树，如果该树不是平衡二叉树时直接返回一个不可能达到的值`-1`来标记  
- **时间复杂度**：每个节点只需遍历一次,时间复杂度:`O(n)`
---
## 四.路径总和
[路径总和](https://leetcode.cn/problems/path-sum/description/)
### 题目描述
- 给定二叉树根节点`root`和一个表示目标和的整数`targetSum`，判断该二叉树中是否存在**从根节点到叶子节点**的路径，这条路径的所有值相加等于`targetSum`

### 思路
- 本题要先搞清**叶子结点的判断**:`if(!root->left&&!root->right)`
- 利用**遍历递归**（自顶向下）的思想:
    - 当前节点不是叶子节点,判断其左右子树是否能满足：`return hasPathSum(root->left,targetSum-root->val)||return hasPathSum(root->right,targetSum-root->val);`
    - 当前节点是叶子节点，判断当前路径是否能满足:`return targetSum==root->val;`

### 复杂度分析
- **时间复杂度**：对每个节点只访问一次，时间复杂度：$O(N)$,其中N为二叉树节点的个数
- **空间复杂度**：$O(H)$,$H$为树的高度。空间复杂度主要取决于**递归时栈空间的开销**。最坏情况下二叉树为链状结构，$H=N$。平均情况下二叉树$H=\log(N)$
---
## 五.反转二叉树
[反转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/)

### 题目描述
- 给一个二叉树根节点`root`，反转这颗二叉树，返回根节点

### 思路
- 要把整棵树反转，只需把左右子树**递归**反转，同时返回左右子树的根节点`left`和`right`。到达空节点时直接返回空指针
- 再交换左右子树`root->left=right`和`root->right=left

---
## 六.二叉搜索树的最小绝对差

[二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/)

### 题目描述

- 给定二叉搜索树的根节点`root`,返回**树中任意两个不同节点值的最小差值**

### 思路

- **二叉搜索树的重要性质**是**中序遍历得到一个严格递增的序列**
- 由于递增序列的**两个不同的节点最小差值**一定是**相邻元素**,故最朴素的想法是用数组记录中序遍历的序列，但是会额外开销空间
- 可以用一个`prev`变量来记录上一个元素，同时用`res`来维护最小差值
- `prev`初始为不可能的值`-1`

---
## 七.二叉树的直径

[二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

### 题目描述
- 给定一个二叉树的根节点`root`，返回二叉树的**直径**
- 二叉树的**直径**是树中任意两个节点之间的最长路径**长度**
- 两个节点**路径的长度**是两个节点之间的**边数**

### 思路

#### 方法一(返回多元组)

- 解决问题的关键是分解问题，先求解**左右子树的直径**
- 在合并问题时，`ans=max(lans,max(rans,ldepth+rdepth+2))`，还要维护树的高度
- 问题的难点在于如何同时问题的解和树的高度
- 问题难点转换为递归何时结束和树的高度和直接如何初始化
- 仔细分析在空节点递归结束，应该把高度和`ans`都初始为`-1`

#### 方法二(维护全局变量)

- 方法一的分解相同问题固然正确,但是在维护一些数据逻辑相对复杂
- 观察一条最长路径一定是经过某个子树的根节点，同时加上左右子树根节点所能扩展的最大节点数(即为树的高度)
- 不如直接维护树的高度，在合并求解原树高度时时，更新问题最大节点数`ans=max(ans,L+R+1)`
- 最后返回**最长路径长度=最大节点数-1**
---

## 八.根据二叉树创建字符串
[根据二叉树创建字符串](https://leetcode.cn/problems/construct-string-from-binary-tree/description/)

### 题目描述
- 给定二叉树的根节点`root`，采用前序遍历的方式，将二叉树创建为一个由数字和括号组成的字符串
- 空节点用`"()"`来表示

### 思路
- 需考虑在处理左右子树时什么时候要加括号： 
    - 处理左子树时：
        - 如果左子树不为空，需要加上一个括号来将左子树括起来。
        - 如果左子树为空:右子树也为空时，此时括号可以直接省略,右子树不为空时，括号不能省略
    - 处理右子树时：
        - 只要右子树不为空，括号不能省略

---
## 九.二叉树中第二小的节点

[二叉树中的第二小节点](https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/description/)

### 题目描述
- 给定一个非空特定二叉树，每个节点都是正数，并且每个节点的孩子个数为`0`或`2`
- 如果一个节点有两个孩子，该节点的值等于孩子节点值的较小者
- 求出该树的第二小值

### 思路
- 问题转换为求**大于根节点值的最小值**
- 容易发现将二叉树遍历一遍即可得到答案
- 直接采用**递归遍历**，维护一个`ans`
- 发现一棵**子树的根节点的值是该子树所有节点值的最小值**
- 如果发现当前`ans`值已经不是`-1`，并且小于等于子树根节点值即可**减去该子树**(该子树中任意节点的值都会大于ans)
- 否则直接更新`ans`，`ans`为大于根节点的最小值即为整棵树的第二小
---
## 十.两数之和

[两数之和1(无序)](https://leetcode.cn/problems/two-sum/description/)

### 题目描述
- 给定一个数组`nums`和一个整数目标值`target`，数组中找到和为`target`的两个数，返回它们的下标值
- 假设每种输入只对应一个解，并且这两个数的下标值不相等

### 思路
- 本题可以采用**暴力**，双重循环，对于每个x，遍历后面的数查看数组中是否有`target-x`
- 发现在找`target-x`的复杂度可以用**哈希**优化，每访问一个x，查看`target-x`是否在哈希表中，如果在直接返回，并把该元素插入哈希表中
- 这样做相当于倒序遍历数组，并检查是否有满足条件的两个数


[两数之和2(有序)](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)

### 题目描述
- 与问题一不同的是，该数组已经排好序

### 思路
- 本题同理可以使用**暴力**，也可以像`1`一样使用哈希，但是我们想着如何在空间上优化
- 用`L`和`R`分别指向数组的起始和结尾，每次计算`sum=nums[L]+nums[R]`
    - 如果`sum==target`,直接返回答案
    - 如果`sum<target`，说明左值太小，左值加上最大的右值都不满足条件，L不可能是答案两个数中的一个，`L++`
    - 如果`sum>target`，说明右值太大，右值加上最小的左值都不满足条件，R不可能是答案中两个数的一个，`R--`
- 下证两个指针不会走过头：
    - 使用反证法，不失一般性假设左指针先走过头
    - 左指针在走过头的过程中一定走到过正确位置，在该位置时，右指针在正确位置的右边，`sum`相加大于`target`，右指针会一直左移到正确位置，这与左指针走过头矛盾。故左指针不会走过头
    - 同理右指针也不会走过头

[两数之和3(输入二叉搜索树)](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/description/)

