
## 一.相同的树
[相同的树](https://leetcode.cn/problems/same-tree/description/)
### 题目描述
- 给定两个二叉树p和q，编写函数判断两个树是否相同

### 思路
- 两个二叉树相同，即两个二叉树相应节点的值都相同
- 可以采用递归的策略，如果当前两个树当前节点相同并且两个树的左子树和右子树分别相同，则两个二叉树相同
- 边界条件: 
    - 当前两个节点都是空指针: `return true;`
    - 当前两个节点都不是空指针:`return p->val==q->val&&isSame(p->left,q->left)&&isSame(p->right,q->right);`
    - 其他(一个为空，另一个不是空):`return fasle;`

### 变式
[对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
- 对称二叉树:给定一个二叉树root节点，判断是否为轴对称
    - 只需判断`root->left`和`root->right`两棵子树是否为轴对称
    - 观察两颗子树轴对称只需当前节点相同，并且一棵树的左(右)子树等于右(左)子树.
---
## 二.二叉树的最大深度
[二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)
### 题目描述
- 给定一个二叉树root，返回其最大深度

### 思路
- 可以采用递归的策略，先求出左右子树的最大深度h，该子树的最大深度为h+1
- 边界条件:
    - 当前节点为空:`return 0;`
    - 当前节点不为空:`return max(maxDepth(root->left),maxDepth(root->right))+1;`
---
## 三.平衡二叉树
[平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/description/)
### 题目描述
- 给定一个二叉树，判定其是否为平衡二叉树(树的所有节点的左右子树的高度相差不超过1)

### 思路

#### 方法一:自顶向底
- 定义一个height函数，一个平衡二叉树满足：左右子树分别是平衡二叉树并且左右子树的高度相差不超过1,即`return abs(height(root->left)-height(root->right))<=1&&isBalanced(root->left)&&isBalanced(root->right);`

- **缺点**：距离叶子节点较近的节点遍历次数较多，复杂度较高

- **时间复杂度**：平均情况下二叉树为满二叉树,`T(n)=2T(n/2)+O(n)`,解方程时间复杂度为`O(n)`

#### 方法二：自底向顶

- 本题要始终维护两个值，子树的高度和子树是否为平衡二叉树
- 维护高度较为容易，直接返回左右子树高度最大值加1
- 维护左右子树是否为平衡二叉树:
    - 首先想到可以传入引用变量ok，每次更新`ok=ok&&(abs(h1-h2)<=1);`，
    **易错点**：在叶子节点时，`ok=ok&&true`。因为当一颗树的左子树不是平衡二叉树时,直接写`ok=true`会误判这棵树为平衡二叉树
    - 另外，还可以通过返回值来维护左右子树是否为平衡二叉树，如果该树不是平衡二叉树时直接返回一个不可能达到的值`-1`来标记  
- **时间复杂度**：每个节点只需遍历一次,时间复杂度:`O(n)`
---
## 四.路径总和
[路径总和](https://leetcode.cn/problems/path-sum/description/)
### 题目描述
- 给定二叉树根节点`root`和一个表示目标和的整数`targetSum`，判断该二叉树中是否存在**从根节点到叶子节点**的路径，这条路径的所有值相加等于`targetSum`

### 思路
- 本题要先搞清**叶子结点的判断**:`if(!root->left&&!root->right)`
- 利用**遍历递归**（自顶向下）的思想:
    - 当前节点不是叶子节点,判断其左右子树是否能满足：`return hasPathSum(root->left,targetSum-root->val)||return hasPathSum(root->right,targetSum-root->val);`
    - 当前节点是叶子节点，判断当前路径是否能满足:`return targetSum==root->val;`

### 复杂度分析
- **时间复杂度**：对每个节点只访问一次，时间复杂度：$O(N)$,其中N为二叉树节点的个数
- **空间复杂度**：$O(H)$,$H$为树的高度。空间复杂度主要取决于**递归时栈空间的开销**。最坏情况下二叉树为链状结构，$H=N$。平均情况下二叉树$H=\log(N)$
---
## 五.反转二叉树
[反转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/)

### 题目描述
- 给一个二叉树根节点`root`，反转这颗二叉树，返回根节点

### 思路
- 要把整棵树反转，只需把左右子树**递归**反转，同时返回左右子树的根节点`left`和`right`。到达空节点时直接返回空指针
- 再交换左右子树`root->left=right`和`root->right=left

---
## 六.二叉搜索树的最小绝对差

[二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/)

