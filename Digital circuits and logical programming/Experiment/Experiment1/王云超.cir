** Design1 **
* 
* NI Multisim to SPICE Netlist Export
* Generated by: YunCh
* Sat, Nov 01, 2025 12:44:29 
*

*## Multisim Component X9 ##*
* !!!BEGIN-INTERACT
*  0.0       VARIABLE pin_index
*  0.0       VARIABLE pin_state
*
*  :ON_USER_UPDATE
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*  ;   
*
*  :OUT_DATA
*   *pin_index GET_REAL_DATA ==>_*pin_state
*   0.9 *pin_state  f.<   if
*       1 7 0 SET_SUBCOMP_PRP
*       1 8 0 SET_SUBCOMP_PRP
*       1 9 0 SET_SUBCOMP_PRP
*       1 10 0 SET_SUBCOMP_PRP
*       1 11 0 SET_SUBCOMP_PRP
*       1 12 0 SET_SUBCOMP_PRP
*       1 13 0 SET_SUBCOMP_PRP
*       1 14 0 SET_SUBCOMP_PRP
*   else
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*   endif
*  ;
*
*  :BEGIN_PLOT
*     GET_NODE_INDEX 1 ==>_*pin_index
*  ;
* !!!END-INTERACT
xX9 36 Probe_digX9
.subckt Probe_digX9 1
a1 1 2 InputBuffer
a2 2 Digload  
.MODEL Digload d_pulldown(load = 1e-12)
.MODEL InputBuffer d_buffer (rise_delay = 1n fall_delay = 1n)
.ends


*## Multisim Component X8 ##*
* !!!BEGIN-INTERACT
*  0.0       VARIABLE pin_index
*  0.0       VARIABLE pin_state
*
*  :ON_USER_UPDATE
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*  ;   
*
*  :OUT_DATA
*   *pin_index GET_REAL_DATA ==>_*pin_state
*   0.9 *pin_state  f.<   if
*       1 7 0 SET_SUBCOMP_PRP
*       1 8 0 SET_SUBCOMP_PRP
*       1 9 0 SET_SUBCOMP_PRP
*       1 10 0 SET_SUBCOMP_PRP
*       1 11 0 SET_SUBCOMP_PRP
*       1 12 0 SET_SUBCOMP_PRP
*       1 13 0 SET_SUBCOMP_PRP
*       1 14 0 SET_SUBCOMP_PRP
*   else
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*   endif
*  ;
*
*  :BEGIN_PLOT
*     GET_NODE_INDEX 1 ==>_*pin_index
*  ;
* !!!END-INTERACT
xX8 35 Probe_digX8
.subckt Probe_digX8 1
a1 1 2 InputBuffer
a2 2 Digload  
.MODEL Digload d_pulldown(load = 1e-12)
.MODEL InputBuffer d_buffer (rise_delay = 1n fall_delay = 1n)
.ends


*## Multisim Component X7 ##*
* !!!BEGIN-INTERACT
*  0.0       VARIABLE pin_index
*  0.0       VARIABLE pin_state
*
*  :ON_USER_UPDATE
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*  ;   
*
*  :OUT_DATA
*   *pin_index GET_REAL_DATA ==>_*pin_state
*   0.9 *pin_state  f.<   if
*       1 7 0 SET_SUBCOMP_PRP
*       1 8 0 SET_SUBCOMP_PRP
*       1 9 0 SET_SUBCOMP_PRP
*       1 10 0 SET_SUBCOMP_PRP
*       1 11 0 SET_SUBCOMP_PRP
*       1 12 0 SET_SUBCOMP_PRP
*       1 13 0 SET_SUBCOMP_PRP
*       1 14 0 SET_SUBCOMP_PRP
*   else
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*   endif
*  ;
*
*  :BEGIN_PLOT
*     GET_NODE_INDEX 1 ==>_*pin_index
*  ;
* !!!END-INTERACT
xX7 34 Probe_digX7
.subckt Probe_digX7 1
a1 1 2 InputBuffer
a2 2 Digload  
.MODEL Digload d_pulldown(load = 1e-12)
.MODEL InputBuffer d_buffer (rise_delay = 1n fall_delay = 1n)
.ends


*## Multisim Component X6 ##*
* !!!BEGIN-INTERACT
*  0.0       VARIABLE pin_index
*  0.0       VARIABLE pin_state
*
*  :ON_USER_UPDATE
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*  ;   
*
*  :OUT_DATA
*   *pin_index GET_REAL_DATA ==>_*pin_state
*   0.9 *pin_state  f.<   if
*       1 7 0 SET_SUBCOMP_PRP
*       1 8 0 SET_SUBCOMP_PRP
*       1 9 0 SET_SUBCOMP_PRP
*       1 10 0 SET_SUBCOMP_PRP
*       1 11 0 SET_SUBCOMP_PRP
*       1 12 0 SET_SUBCOMP_PRP
*       1 13 0 SET_SUBCOMP_PRP
*       1 14 0 SET_SUBCOMP_PRP
*   else
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*   endif
*  ;
*
*  :BEGIN_PLOT
*     GET_NODE_INDEX 1 ==>_*pin_index
*  ;
* !!!END-INTERACT
xX6 33 Probe_digX6
.subckt Probe_digX6 1
a1 1 2 InputBuffer
a2 2 Digload  
.MODEL Digload d_pulldown(load = 1e-12)
.MODEL InputBuffer d_buffer (rise_delay = 1n fall_delay = 1n)
.ends


*## Multisim Component X5 ##*
* !!!BEGIN-INTERACT
*  0.0       VARIABLE pin_index
*  0.0       VARIABLE pin_state
*
*  :ON_USER_UPDATE
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*  ;   
*
*  :OUT_DATA
*   *pin_index GET_REAL_DATA ==>_*pin_state
*   0.9 *pin_state  f.<   if
*       1 7 0 SET_SUBCOMP_PRP
*       1 8 0 SET_SUBCOMP_PRP
*       1 9 0 SET_SUBCOMP_PRP
*       1 10 0 SET_SUBCOMP_PRP
*       1 11 0 SET_SUBCOMP_PRP
*       1 12 0 SET_SUBCOMP_PRP
*       1 13 0 SET_SUBCOMP_PRP
*       1 14 0 SET_SUBCOMP_PRP
*   else
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*   endif
*  ;
*
*  :BEGIN_PLOT
*     GET_NODE_INDEX 1 ==>_*pin_index
*  ;
* !!!END-INTERACT
xX5 32 Probe_digX5
.subckt Probe_digX5 1
a1 1 2 InputBuffer
a2 2 Digload  
.MODEL Digload d_pulldown(load = 1e-12)
.MODEL InputBuffer d_buffer (rise_delay = 1n fall_delay = 1n)
.ends


*## Multisim Component X4 ##*
* !!!BEGIN-INTERACT
*  0.0       VARIABLE pin_index
*  0.0       VARIABLE pin_state
*
*  :ON_USER_UPDATE
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*  ;   
*
*  :OUT_DATA
*   *pin_index GET_REAL_DATA ==>_*pin_state
*   0.9 *pin_state  f.<   if
*       1 7 0 SET_SUBCOMP_PRP
*       1 8 0 SET_SUBCOMP_PRP
*       1 9 0 SET_SUBCOMP_PRP
*       1 10 0 SET_SUBCOMP_PRP
*       1 11 0 SET_SUBCOMP_PRP
*       1 12 0 SET_SUBCOMP_PRP
*       1 13 0 SET_SUBCOMP_PRP
*       1 14 0 SET_SUBCOMP_PRP
*   else
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*   endif
*  ;
*
*  :BEGIN_PLOT
*     GET_NODE_INDEX 1 ==>_*pin_index
*  ;
* !!!END-INTERACT
xX4 31 Probe_digX4
.subckt Probe_digX4 1
a1 1 2 InputBuffer
a2 2 Digload  
.MODEL Digload d_pulldown(load = 1e-12)
.MODEL InputBuffer d_buffer (rise_delay = 1n fall_delay = 1n)
.ends


*## Multisim Component X3 ##*
* !!!BEGIN-INTERACT
*  0.0       VARIABLE pin_index
*  0.0       VARIABLE pin_state
*
*  :ON_USER_UPDATE
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*  ;   
*
*  :OUT_DATA
*   *pin_index GET_REAL_DATA ==>_*pin_state
*   0.9 *pin_state  f.<   if
*       1 7 0 SET_SUBCOMP_PRP
*       1 8 0 SET_SUBCOMP_PRP
*       1 9 0 SET_SUBCOMP_PRP
*       1 10 0 SET_SUBCOMP_PRP
*       1 11 0 SET_SUBCOMP_PRP
*       1 12 0 SET_SUBCOMP_PRP
*       1 13 0 SET_SUBCOMP_PRP
*       1 14 0 SET_SUBCOMP_PRP
*   else
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*   endif
*  ;
*
*  :BEGIN_PLOT
*     GET_NODE_INDEX 1 ==>_*pin_index
*  ;
* !!!END-INTERACT
xX3 30 Probe_digX3
.subckt Probe_digX3 1
a1 1 2 InputBuffer
a2 2 Digload  
.MODEL Digload d_pulldown(load = 1e-12)
.MODEL InputBuffer d_buffer (rise_delay = 1n fall_delay = 1n)
.ends


*## Multisim Component X2 ##*
* !!!BEGIN-INTERACT
*  0.0       VARIABLE pin_index
*  0.0       VARIABLE pin_state
*
*  :ON_USER_UPDATE
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*  ;   
*
*  :OUT_DATA
*   *pin_index GET_REAL_DATA ==>_*pin_state
*   0.9 *pin_state  f.<   if
*       1 7 0 SET_SUBCOMP_PRP
*       1 8 0 SET_SUBCOMP_PRP
*       1 9 0 SET_SUBCOMP_PRP
*       1 10 0 SET_SUBCOMP_PRP
*       1 11 0 SET_SUBCOMP_PRP
*       1 12 0 SET_SUBCOMP_PRP
*       1 13 0 SET_SUBCOMP_PRP
*       1 14 0 SET_SUBCOMP_PRP
*   else
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*   endif
*  ;
*
*  :BEGIN_PLOT
*     GET_NODE_INDEX 1 ==>_*pin_index
*  ;
* !!!END-INTERACT
xX2 29 Probe_digX2
.subckt Probe_digX2 1
a1 1 2 InputBuffer
a2 2 Digload  
.MODEL Digload d_pulldown(load = 1e-12)
.MODEL InputBuffer d_buffer (rise_delay = 1n fall_delay = 1n)
.ends


*## Multisim Component X1 ##*
* !!!BEGIN-INTERACT
*  0.0       VARIABLE pin_index
*  0.0       VARIABLE pin_state
*
*  :ON_USER_UPDATE
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*  ;   
*
*  :OUT_DATA
*   *pin_index GET_REAL_DATA ==>_*pin_state
*   0.9 *pin_state  f.<   if
*       1 7 0 SET_SUBCOMP_PRP
*       1 8 0 SET_SUBCOMP_PRP
*       1 9 0 SET_SUBCOMP_PRP
*       1 10 0 SET_SUBCOMP_PRP
*       1 11 0 SET_SUBCOMP_PRP
*       1 12 0 SET_SUBCOMP_PRP
*       1 13 0 SET_SUBCOMP_PRP
*       1 14 0 SET_SUBCOMP_PRP
*   else
*       0 7 0 SET_SUBCOMP_PRP
*       0 8 0 SET_SUBCOMP_PRP
*       0 9 0 SET_SUBCOMP_PRP
*       0 10 0 SET_SUBCOMP_PRP
*       0 11 0 SET_SUBCOMP_PRP
*       0 12 0 SET_SUBCOMP_PRP
*       0 13 0 SET_SUBCOMP_PRP
*       0 14 0 SET_SUBCOMP_PRP
*   endif
*  ;
*
*  :BEGIN_PLOT
*     GET_NODE_INDEX 1 ==>_*pin_index
*  ;
* !!!END-INTERACT
xX1 28 Probe_digX1
.subckt Probe_digX1 1
a1 1 2 InputBuffer
a2 2 Digload  
.MODEL Digload d_pulldown(load = 1e-12)
.MODEL InputBuffer d_buffer (rise_delay = 1n fall_delay = 1n)
.ends


*## Multisim Component V8 ##*
vV8 27 0
+   pulse( 0 5 0 1e-009 1e-009
+   {50*0.01/1000}
+   {1/1000})

*## Multisim Component V7 ##*
vV7 26 0 dc 2.405 ac 0 0
+           distof1 0 0
+           distof2 0 0

*## Multisim Component U12 ##*
xU12    25
+      26
+      U12--2.0
+      28
+      29
+      30
+      31
+      32
+      33
+      34
+      35
+      dU12.SOC
+      36 ADC8__ADC_DAC__1

vU12.PinVoltageVref---0 0 U12--2.0 DC 0.0









xU12.SOC 27 dU12.SOC TIL_RCV__NON__1



*## Multisim Component U5 ##*
* !!!BEGIN-INTERACT
*
*  ( External state variables )
*  : Rshunt              ++++f1 ;
*  : Mode                 ++++i3 ;
*
*  ( Internal state variables )
*  0.0      VARIABLE   r1Volt
*  0.0      VARIABLE   r1Cur
*  0         VARIABLE   nTime
*  0         VARIABLE   nTimeCur
*
*  .( Loading the voltmeter.. )  cr
*
*  :  RESET
*       0.0  VALUE  SET_ANIMATION_TEXT
*       Rshunt  SET_INSTANCE Resistor ::R r1 resistance
*       1   RESET_ACDC
*       GET_LOCAL_TIME   ==>_*nTime
*  ;
*
*  :BEGIN_PLOT
*    RESET
*  ;
*
*  :OUT_DATA
*   GET_INSTANCE Resistor ::R r1 i  ==>_*r1Cur
*   (( Rshunt  *r1Cur  f.*  )) 1 ADD_ACDC
*   GET_LOCAL_TIME   ==>_*nTimeCur
*   *nTimeCur *nTime - 2 >= if
*   ((if Mode 1 GET_AC 1 GET_DC ))if   VALUE  SET_ANIMATION_TEXT
*   *nTimeCur   ==>_*nTime
*  endif
*  ;
*
* :  BEGIN_ANALYSIS 
*        RESET
*    ;
*     1  ACDC::ALLOC_INDEX
*
* :SIMULATION_CHANGED
*    ACDC::CIRCUIT_CHANGE
*    GET_LOCAL_TIME   ==>_*nTime
* ;
*
* !!!END-INTERACT

xU5 8 0  VoltmeterU5

.subckt voltmeterU5 1 2
R1 1 2 1e6
.ends

*## Multisim Component U11 ##*
xU11 24 25 25 3T_VirtualU11 PARAMS: Vos=0 Ib=0 Ioff=0 Av=200000 BW=100000000 Rin=10000000 Rout=10 Vpos=12 Vneg=-12 

.SUBCKT 3T_VirtualU11 in_pos in_neg out PARAMS: Av=500k BW=10Meg Rin=10Meg Rout=0 Vos=0 Ib=0 Ioff=0 Vpos=15 Vneg=-15 

* Input Stage: Rin, Ibias, Voffset
Vos in_pos 4 {Vos}
Ibias1 4 0 {Ib}
Ibias2 in_neg 0 {Ib}
Ios 4 in_neg {Ioff/2}
Rin 4 in_neg {Rin}

*Middle stage: Gain, frequency, voltage limiting
Bgain 0 6 I={v(4,in_neg)*Av/1meg }
R1 6 0 1meg
CP1 6 0 {Av/(2*pi*1meg*BW)}


Vpos 9 0 {Vpos}
Dlimit_pos 6 9 d1

Vneg 10 0 {Vneg}
Dlimit_neg 10 6 d1

.model d1 d(n=0.1) 

*Output stage: Buffer, output resistance 
E2 7 0 6 0 1
Rout 7 out {Rout}
.ends

*## Multisim Instrument XSC1 ##*


*## Multisim Component U10 ##*
xU10 22 23 24 3T_VirtualU10 PARAMS: Vos=0 Ib=0 Ioff=0 Av=200000 BW=100000000 Rin=10000000 Rout=10 Vpos=12 Vneg=-12 

.SUBCKT 3T_VirtualU10 in_pos in_neg out PARAMS: Av=500k BW=10Meg Rin=10Meg Rout=0 Vos=0 Ib=0 Ioff=0 Vpos=15 Vneg=-15 

* Input Stage: Rin, Ibias, Voffset
Vos in_pos 4 {Vos}
Ibias1 4 0 {Ib}
Ibias2 in_neg 0 {Ib}
Ios 4 in_neg {Ioff/2}
Rin 4 in_neg {Rin}

*Middle stage: Gain, frequency, voltage limiting
Bgain 0 6 I={v(4,in_neg)*Av/1meg }
R1 6 0 1meg
CP1 6 0 {Av/(2*pi*1meg*BW)}


Vpos 9 0 {Vpos}
Dlimit_pos 6 9 d1

Vneg 10 0 {Vneg}
Dlimit_neg 10 6 d1

.model d1 d(n=0.1) 

*Output stage: Buffer, output resistance 
E2 7 0 6 0 1
Rout 7 out {Rout}
.ends

*## Multisim Component C1 ##*
cC1 22 0 4.8e-007

*## Multisim Component R11 ##*
rR11 23 24 20 vresR11  
.model vresR11 r(  )

*## Multisim Component R10 ##*
rR10 0 23 20 vresR10  
.model vresR10 r(  )

*## Multisim Component R9 ##*
rR9 21 22 200000 vresR9  
.model vresR9 r(  )

*## Multisim Component V6 ##*
aV6 21 8 THERMAL_NOISEV6
.MODEL THERMAL_NOISEV6 noise_source(
+ noise_ratio= 1 resistance= 1000 temperature= {27+273.15} bandwith= 10000000 )

*## Multisim Component R8 ##*
rR8 7 8 10000 vresR8  
.model vresR8 r(  )

*## Multisim Component R7 ##*
rR7 5 7 100 vresR7  
.model vresR7 r(  )

*## Multisim Component R6 ##*
rR6 6 0 10000 vresR6  
.model vresR6 r(  )

*## Multisim Component R5 ##*
rR5 4 6 100 vresR5  
.model vresR5 r(  )

*## Multisim Component U4 ##*
xU4 6 7 8 3T_VirtualU4 PARAMS: Vos=0 Ib=0 Ioff=0 Av=200000 BW=100000000 Rin=10000000 Rout=10 Vpos=12 Vneg=-12 

.SUBCKT 3T_VirtualU4 in_pos in_neg out PARAMS: Av=500k BW=10Meg Rin=10Meg Rout=0 Vos=0 Ib=0 Ioff=0 Vpos=15 Vneg=-15 

* Input Stage: Rin, Ibias, Voffset
Vos in_pos 4 {Vos}
Ibias1 4 0 {Ib}
Ibias2 in_neg 0 {Ib}
Ios 4 in_neg {Ioff/2}
Rin 4 in_neg {Rin}

*Middle stage: Gain, frequency, voltage limiting
Bgain 0 6 I={v(4,in_neg)*Av/1meg }
R1 6 0 1meg
CP1 6 0 {Av/(2*pi*1meg*BW)}


Vpos 9 0 {Vpos}
Dlimit_pos 6 9 d1

Vneg 10 0 {Vneg}
Dlimit_neg 10 6 d1

.model d1 d(n=0.1) 

*Output stage: Buffer, output resistance 
E2 7 0 6 0 1
Rout 7 out {Rout}
.ends

*## Multisim Component U3 ##*
xU3 11 5 5 3T_VirtualU3 PARAMS: Vos=0 Ib=0 Ioff=0 Av=200000 BW=100000000 Rin=10000000 Rout=10 Vpos=12 Vneg=-12 

.SUBCKT 3T_VirtualU3 in_pos in_neg out PARAMS: Av=500k BW=10Meg Rin=10Meg Rout=0 Vos=0 Ib=0 Ioff=0 Vpos=15 Vneg=-15 

* Input Stage: Rin, Ibias, Voffset
Vos in_pos 4 {Vos}
Ibias1 4 0 {Ib}
Ibias2 in_neg 0 {Ib}
Ios 4 in_neg {Ioff/2}
Rin 4 in_neg {Rin}

*Middle stage: Gain, frequency, voltage limiting
Bgain 0 6 I={v(4,in_neg)*Av/1meg }
R1 6 0 1meg
CP1 6 0 {Av/(2*pi*1meg*BW)}


Vpos 9 0 {Vpos}
Dlimit_pos 6 9 d1

Vneg 10 0 {Vneg}
Dlimit_neg 10 6 d1

.model d1 d(n=0.1) 

*Output stage: Buffer, output resistance 
E2 7 0 6 0 1
Rout 7 out {Rout}
.ends

*## Multisim Component U2 ##*
xU2 3 4 4 3T_VirtualU2 PARAMS: Vos=0 Ib=0 Ioff=0 Av=200000 BW=100000000 Rin=10000000 Rout=10 Vpos=12 Vneg=-12 

.SUBCKT 3T_VirtualU2 in_pos in_neg out PARAMS: Av=500k BW=10Meg Rin=10Meg Rout=0 Vos=0 Ib=0 Ioff=0 Vpos=15 Vneg=-15 

* Input Stage: Rin, Ibias, Voffset
Vos in_pos 4 {Vos}
Ibias1 4 0 {Ib}
Ibias2 in_neg 0 {Ib}
Ios 4 in_neg {Ioff/2}
Rin 4 in_neg {Rin}

*Middle stage: Gain, frequency, voltage limiting
Bgain 0 6 I={v(4,in_neg)*Av/1meg }
R1 6 0 1meg
CP1 6 0 {Av/(2*pi*1meg*BW)}


Vpos 9 0 {Vpos}
Dlimit_pos 6 9 d1

Vneg 10 0 {Vneg}
Dlimit_neg 10 6 d1

.model d1 d(n=0.1) 

*Output stage: Buffer, output resistance 
E2 7 0 6 0 1
Rout 7 out {Rout}
.ends

*## Multisim Component V2 ##*
* !!!BEGIN-INTERACT
*  : increment  ++++f8 ;
*  : tmaxvalue  ++++f4 ;
*  : tminvalue  ++++f6 ;
*  0.0          constant mindval
*  100.0        constant maxdval
*  tmaxvalue    VARIABLE maxvalue
*  tminvalue    VARIABLE minvalue
*  50.0         VARIABLE setting
*  0            VARIABLE num_stored
*  0.0          VARIABLE setsourceval
*  0.0          VARIABLE zeroadj
*  0.0          VARIABLE setfactor
*  0            VARIABLE flag
*  0.0          VARIABLE outputval
*
*  :MAP_KEYBOARD_INPUT ++++k1 1 ++++K1  -1 ;
*
*  : UPDATE_SETTINGS
*     *flag 0 = if
*        LOAD_FICL_VARIABLES
*        ==>_*num_stored
*        ==>_*num_stored
*        *num_stored 0 > if
*           ==>_*setting 
*           ==>_*setsourceval
*          *setsourceval SET_INSTANCE vsource ::V V1  dc
*        endif
*      1 ==>_*flag
*      endif
*      0.01 *setting f.* ==>_*setfactor
*      tmaxvalue tminvalue f.- *setfactor f.* tminvalue f.+ ==>_*outputval
*      *outputval VALUE 0 SET_ANIMATION_TEXT_BYID
*      *outputval maxvalue GRADUAL_CHANGE_AT_RUN
*      *outputval *setting 2 0
*      STORE_FICL_VARIABLES
*  ;
*
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*    value SET_INSTANCE vsource ::V V1  dc
*  ;
*
*  :KEYBOARD_INPUT locals| shift_state |
*     shift_state (float) increment f.* *setting  f.+  ==>_*setting
*     mindval maxdval *setting f.min f.max ==>_*setting
*     UPDATE_SETTINGS
*  ;
*
*  :BEGIN_PLOT
*     UPDATE_SETTINGS
*  ;
*
*  :BEGIN_ANALYSIS
*    UPDATE_SETTINGS
*  ;
*
*  : INIT_SLIDER
*      maxdval mindval 3 IMOUSE_SET
*  ;
*
*  : ON_IMOUSE_EVENT locals| eType fValue |
*    eType 9 = if
*      -1
*      fValue ==>_*setting
*    else
*      0
*    endif
*    UPDATE_SETTINGS
*  ;
*
*  : GET_INTERACT_VALUE locals| eType |
*      eType 0 = if
*        *setting
*      else eType 1 = if
*        mindval
*      else eType 2 = if
*        maxdval
*      else eType 3 = if
*        increment
*      else
*        0
*      endif endif endif endif
*  ;
*
*  : SET_INTERACT_VALUE locals| eType fValue |
*      eType 0 = if
*        fValue ==>_*setting
*      endif
*      UPDATE_SETTINGS
*  ;
*
*  :ON_USER_UPDATE
*    UPDATE_SETTINGS
*    INIT_SLIDER
*  ;
*
* !!!END-INTERACT
xV2 14 13 VariableDCVoltageV2
.subckt VariableDCVoltageV2 1 2
V1 1 2  10
.ends

*## Multisim Component U9 ##*
* !!!BEGIN-INTERACT
*  : Ohms_per_Volt  ++++f2 ;
*  0.0  VARIABLE    Resistor_Current
*  0.0  VARIABLE    Applied_Voltage
*  0.0  VARIABLE    Resulting_Resistance
*
* :OUT_DATA
*     GET_INSTANCE Vsource ::V Vsns i ==>_*Resistor_Current
*     *Resistor_Current 1.0e9 f.* ==>_*Applied_Voltage
*     *Applied_Voltage f.abs ==>_*Applied_Voltage
*     Ohms_per_Volt *Applied_Voltage f.* ==>_*Resulting_Resistance
*     *Resulting_Resistance VALUE 0 SET_ANIMATION_TEXT_BYID
* ;
*
* :ON_USER_UPDATE
*     0.0 ==>_*Resistor_Current
*     0.0 ==>_*Applied_Voltage
*     0.0 ==>_*Resulting_Resistance
* ;
*
* !!!END-INTERACT
xU9 19 20 12 11 Voltage_Controlled_ResistorU9 PARAMS: Ohms_per_Volt=0.004185
.subckt Voltage_Controlled_ResistorU9 1 2 4 5 PARAMS: Ohms_per_Volt=1
RIN 1 1a 1G
Vsns 1a 2 DC 0
EOUT  4 6 POLY(2) (1,2) (3,0) 0 0 0 0 {Ohms_per_Volt/1000}
FCOPY 0 3 VSENSE 1
RSENSOR 3 0 1K
* CURRENT SENSE
VSENSE  6 5 0
.ENDS

*## Multisim Component U8 ##*
* !!!BEGIN-INTERACT
*  : Ohms_per_Volt  ++++f2 ;
*  0.0  VARIABLE    Resistor_Current
*  0.0  VARIABLE    Applied_Voltage
*  0.0  VARIABLE    Resulting_Resistance
*
* :OUT_DATA
*     GET_INSTANCE Vsource ::V Vsns i ==>_*Resistor_Current
*     *Resistor_Current 1.0e9 f.* ==>_*Applied_Voltage
*     *Applied_Voltage f.abs ==>_*Applied_Voltage
*     Ohms_per_Volt *Applied_Voltage f.* ==>_*Resulting_Resistance
*     *Resulting_Resistance VALUE 0 SET_ANIMATION_TEXT_BYID
* ;
*
* :ON_USER_UPDATE
*     0.0 ==>_*Resistor_Current
*     0.0 ==>_*Applied_Voltage
*     0.0 ==>_*Resulting_Resistance
* ;
*
* !!!END-INTERACT
xU8 15 16 9 3 Voltage_Controlled_ResistorU8 PARAMS: Ohms_per_Volt=0.004185
.subckt Voltage_Controlled_ResistorU8 1 2 4 5 PARAMS: Ohms_per_Volt=1
RIN 1 1a 1G
Vsns 1a 2 DC 0
EOUT  4 6 POLY(2) (1,2) (3,0) 0 0 0 0 {Ohms_per_Volt/1000}
FCOPY 0 3 VSENSE 1
RSENSOR 3 0 1K
* CURRENT SENSE
VSENSE  6 5 0
.ENDS

*## Multisim Component U7 ##*
* !!!BEGIN-INTERACT
*  : Ohms_per_Volt  ++++f2 ;
*  0.0  VARIABLE    Resistor_Current
*  0.0  VARIABLE    Applied_Voltage
*  0.0  VARIABLE    Resulting_Resistance
*
* :OUT_DATA
*     GET_INSTANCE Vsource ::V Vsns i ==>_*Resistor_Current
*     *Resistor_Current 1.0e9 f.* ==>_*Applied_Voltage
*     *Applied_Voltage f.abs ==>_*Applied_Voltage
*     Ohms_per_Volt *Applied_Voltage f.* ==>_*Resulting_Resistance
*     *Resulting_Resistance VALUE 0 SET_ANIMATION_TEXT_BYID
* ;
*
* :ON_USER_UPDATE
*     0.0 ==>_*Resistor_Current
*     0.0 ==>_*Applied_Voltage
*     0.0 ==>_*Resulting_Resistance
* ;
*
* !!!END-INTERACT
xU7 17 18 11 10 Voltage_Controlled_ResistorU7 PARAMS: Ohms_per_Volt=0.004185
.subckt Voltage_Controlled_ResistorU7 1 2 4 5 PARAMS: Ohms_per_Volt=1
RIN 1 1a 1G
Vsns 1a 2 DC 0
EOUT  4 6 POLY(2) (1,2) (3,0) 0 0 0 0 {Ohms_per_Volt/1000}
FCOPY 0 3 VSENSE 1
RSENSOR 3 0 1K
* CURRENT SENSE
VSENSE  6 5 0
.ENDS

*## Multisim Component V5 ##*
* !!!BEGIN-INTERACT
*  : increment  ++++f8 ;
*  : tmaxvalue  ++++f4 ;
*  : tminvalue  ++++f6 ;
*  0.0          constant mindval
*  100.0        constant maxdval
*  tmaxvalue    VARIABLE maxvalue
*  tminvalue    VARIABLE minvalue
*  50.0         VARIABLE setting
*  0            VARIABLE num_stored
*  0.0          VARIABLE setsourceval
*  0.0          VARIABLE zeroadj
*  0.0          VARIABLE setfactor
*  0            VARIABLE flag
*  0.0          VARIABLE outputval
*
*  :MAP_KEYBOARD_INPUT ++++k1 1 ++++K1  -1 ;
*
*  : UPDATE_SETTINGS
*     *flag 0 = if
*        LOAD_FICL_VARIABLES
*        ==>_*num_stored
*        ==>_*num_stored
*        *num_stored 0 > if
*           ==>_*setting 
*           ==>_*setsourceval
*          *setsourceval SET_INSTANCE vsource ::V V1  dc
*        endif
*      1 ==>_*flag
*      endif
*      0.01 *setting f.* ==>_*setfactor
*      tmaxvalue tminvalue f.- *setfactor f.* tminvalue f.+ ==>_*outputval
*      *outputval VALUE 0 SET_ANIMATION_TEXT_BYID
*      *outputval maxvalue GRADUAL_CHANGE_AT_RUN
*      *outputval *setting 2 0
*      STORE_FICL_VARIABLES
*  ;
*
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*    value SET_INSTANCE vsource ::V V1  dc
*  ;
*
*  :KEYBOARD_INPUT locals| shift_state |
*     shift_state (float) increment f.* *setting  f.+  ==>_*setting
*     mindval maxdval *setting f.min f.max ==>_*setting
*     UPDATE_SETTINGS
*  ;
*
*  :BEGIN_PLOT
*     UPDATE_SETTINGS
*  ;
*
*  :BEGIN_ANALYSIS
*    UPDATE_SETTINGS
*  ;
*
*  : INIT_SLIDER
*      maxdval mindval 3 IMOUSE_SET
*  ;
*
*  : ON_IMOUSE_EVENT locals| eType fValue |
*    eType 9 = if
*      -1
*      fValue ==>_*setting
*    else
*      0
*    endif
*    UPDATE_SETTINGS
*  ;
*
*  : GET_INTERACT_VALUE locals| eType |
*      eType 0 = if
*        *setting
*      else eType 1 = if
*        mindval
*      else eType 2 = if
*        maxdval
*      else eType 3 = if
*        increment
*      else
*        0
*      endif endif endif endif
*  ;
*
*  : SET_INTERACT_VALUE locals| eType fValue |
*      eType 0 = if
*        fValue ==>_*setting
*      endif
*      UPDATE_SETTINGS
*  ;
*
*  :ON_USER_UPDATE
*    UPDATE_SETTINGS
*    INIT_SLIDER
*  ;
*
* !!!END-INTERACT
xV5 20 19 VariableDCVoltageV5
.subckt VariableDCVoltageV5 1 2
V1 1 2  10
.ends

*## Multisim Component V4 ##*
* !!!BEGIN-INTERACT
*  : increment  ++++f8 ;
*  : tmaxvalue  ++++f4 ;
*  : tminvalue  ++++f6 ;
*  0.0          constant mindval
*  100.0        constant maxdval
*  tmaxvalue    VARIABLE maxvalue
*  tminvalue    VARIABLE minvalue
*  50.0         VARIABLE setting
*  0            VARIABLE num_stored
*  0.0          VARIABLE setsourceval
*  0.0          VARIABLE zeroadj
*  0.0          VARIABLE setfactor
*  0            VARIABLE flag
*  0.0          VARIABLE outputval
*
*  :MAP_KEYBOARD_INPUT ++++k1 1 ++++K1  -1 ;
*
*  : UPDATE_SETTINGS
*     *flag 0 = if
*        LOAD_FICL_VARIABLES
*        ==>_*num_stored
*        ==>_*num_stored
*        *num_stored 0 > if
*           ==>_*setting 
*           ==>_*setsourceval
*          *setsourceval SET_INSTANCE vsource ::V V1  dc
*        endif
*      1 ==>_*flag
*      endif
*      0.01 *setting f.* ==>_*setfactor
*      tmaxvalue tminvalue f.- *setfactor f.* tminvalue f.+ ==>_*outputval
*      *outputval VALUE 0 SET_ANIMATION_TEXT_BYID
*      *outputval maxvalue GRADUAL_CHANGE_AT_RUN
*      *outputval *setting 2 0
*      STORE_FICL_VARIABLES
*  ;
*
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*    value SET_INSTANCE vsource ::V V1  dc
*  ;
*
*  :KEYBOARD_INPUT locals| shift_state |
*     shift_state (float) increment f.* *setting  f.+  ==>_*setting
*     mindval maxdval *setting f.min f.max ==>_*setting
*     UPDATE_SETTINGS
*  ;
*
*  :BEGIN_PLOT
*     UPDATE_SETTINGS
*  ;
*
*  :BEGIN_ANALYSIS
*    UPDATE_SETTINGS
*  ;
*
*  : INIT_SLIDER
*      maxdval mindval 3 IMOUSE_SET
*  ;
*
*  : ON_IMOUSE_EVENT locals| eType fValue |
*    eType 9 = if
*      -1
*      fValue ==>_*setting
*    else
*      0
*    endif
*    UPDATE_SETTINGS
*  ;
*
*  : GET_INTERACT_VALUE locals| eType |
*      eType 0 = if
*        *setting
*      else eType 1 = if
*        mindval
*      else eType 2 = if
*        maxdval
*      else eType 3 = if
*        increment
*      else
*        0
*      endif endif endif endif
*  ;
*
*  : SET_INTERACT_VALUE locals| eType fValue |
*      eType 0 = if
*        fValue ==>_*setting
*      endif
*      UPDATE_SETTINGS
*  ;
*
*  :ON_USER_UPDATE
*    UPDATE_SETTINGS
*    INIT_SLIDER
*  ;
*
* !!!END-INTERACT
xV4 15 16 VariableDCVoltageV4
.subckt VariableDCVoltageV4 1 2
V1 1 2  10
.ends

*## Multisim Component V3 ##*
* !!!BEGIN-INTERACT
*  : increment  ++++f8 ;
*  : tmaxvalue  ++++f4 ;
*  : tminvalue  ++++f6 ;
*  0.0          constant mindval
*  100.0        constant maxdval
*  tmaxvalue    VARIABLE maxvalue
*  tminvalue    VARIABLE minvalue
*  50.0         VARIABLE setting
*  0            VARIABLE num_stored
*  0.0          VARIABLE setsourceval
*  0.0          VARIABLE zeroadj
*  0.0          VARIABLE setfactor
*  0            VARIABLE flag
*  0.0          VARIABLE outputval
*
*  :MAP_KEYBOARD_INPUT ++++k1 1 ++++K1  -1 ;
*
*  : UPDATE_SETTINGS
*     *flag 0 = if
*        LOAD_FICL_VARIABLES
*        ==>_*num_stored
*        ==>_*num_stored
*        *num_stored 0 > if
*           ==>_*setting 
*           ==>_*setsourceval
*          *setsourceval SET_INSTANCE vsource ::V V1  dc
*        endif
*      1 ==>_*flag
*      endif
*      0.01 *setting f.* ==>_*setfactor
*      tmaxvalue tminvalue f.- *setfactor f.* tminvalue f.+ ==>_*outputval
*      *outputval VALUE 0 SET_ANIMATION_TEXT_BYID
*      *outputval maxvalue GRADUAL_CHANGE_AT_RUN
*      *outputval *setting 2 0
*      STORE_FICL_VARIABLES
*  ;
*
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*    value SET_INSTANCE vsource ::V V1  dc
*  ;
*
*  :KEYBOARD_INPUT locals| shift_state |
*     shift_state (float) increment f.* *setting  f.+  ==>_*setting
*     mindval maxdval *setting f.min f.max ==>_*setting
*     UPDATE_SETTINGS
*  ;
*
*  :BEGIN_PLOT
*     UPDATE_SETTINGS
*  ;
*
*  :BEGIN_ANALYSIS
*    UPDATE_SETTINGS
*  ;
*
*  : INIT_SLIDER
*      maxdval mindval 3 IMOUSE_SET
*  ;
*
*  : ON_IMOUSE_EVENT locals| eType fValue |
*    eType 9 = if
*      -1
*      fValue ==>_*setting
*    else
*      0
*    endif
*    UPDATE_SETTINGS
*  ;
*
*  : GET_INTERACT_VALUE locals| eType |
*      eType 0 = if
*        *setting
*      else eType 1 = if
*        mindval
*      else eType 2 = if
*        maxdval
*      else eType 3 = if
*        increment
*      else
*        0
*      endif endif endif endif
*  ;
*
*  : SET_INTERACT_VALUE locals| eType fValue |
*      eType 0 = if
*        fValue ==>_*setting
*      endif
*      UPDATE_SETTINGS
*  ;
*
*  :ON_USER_UPDATE
*    UPDATE_SETTINGS
*    INIT_SLIDER
*  ;
*
* !!!END-INTERACT
xV3 17 18 VariableDCVoltageV3
.subckt VariableDCVoltageV3 1 2
V1 1 2  10
.ends

*## Multisim Component U6 ##*
* !!!BEGIN-INTERACT
*  : Ohms_per_Volt  ++++f2 ;
*  0.0  VARIABLE    Resistor_Current
*  0.0  VARIABLE    Applied_Voltage
*  0.0  VARIABLE    Resulting_Resistance
*
* :OUT_DATA
*     GET_INSTANCE Vsource ::V Vsns i ==>_*Resistor_Current
*     *Resistor_Current 1.0e9 f.* ==>_*Applied_Voltage
*     *Applied_Voltage f.abs ==>_*Applied_Voltage
*     Ohms_per_Volt *Applied_Voltage f.* ==>_*Resulting_Resistance
*     *Resulting_Resistance VALUE 0 SET_ANIMATION_TEXT_BYID
* ;
*
* :ON_USER_UPDATE
*     0.0 ==>_*Resistor_Current
*     0.0 ==>_*Applied_Voltage
*     0.0 ==>_*Resulting_Resistance
* ;
*
* !!!END-INTERACT
xU6 13 14 3 2 Voltage_Controlled_ResistorU6 PARAMS: Ohms_per_Volt=0.004185
.subckt Voltage_Controlled_ResistorU6 1 2 4 5 PARAMS: Ohms_per_Volt=1
RIN 1 1a 1G
Vsns 1a 2 DC 0
EOUT  4 6 POLY(2) (1,2) (3,0) 0 0 0 0 {Ohms_per_Volt/1000}
FCOPY 0 3 VSENSE 1
RSENSOR 3 0 1K
* CURRENT SENSE
VSENSE  6 5 0
.ENDS

*## Multisim Component U1 ##*
* !!!BEGIN-INTERACT
*
*  ( External state variables )
*  : Rshunt              ++++f1 ;
*  : Mode                 ++++i3 ;
*
*  ( Internal state variables )
*  0.0      VARIABLE   r1Volt
*  0.0      VARIABLE   r1Cur
*  0         VARIABLE   nTime
*  0         VARIABLE   nTimeCur
*
*  .( Loading the voltmeter.. )  cr
*
*  :  RESET
*       0.0  VALUE  SET_ANIMATION_TEXT
*       Rshunt  SET_INSTANCE Resistor ::R r1 resistance
*       1   RESET_ACDC
*       GET_LOCAL_TIME   ==>_*nTime
*  ;
*
*  :BEGIN_PLOT
*    RESET
*  ;
*
*  :OUT_DATA
*   GET_INSTANCE Resistor ::R r1 i  ==>_*r1Cur
*   (( Rshunt  *r1Cur  f.*  )) 1 ADD_ACDC
*   GET_LOCAL_TIME   ==>_*nTimeCur
*   *nTimeCur *nTime - 2 >= if
*   ((if Mode 1 GET_AC 1 GET_DC ))if   VALUE  SET_ANIMATION_TEXT
*   *nTimeCur   ==>_*nTime
*  endif
*  ;
*
* :  BEGIN_ANALYSIS 
*        RESET
*    ;
*     1  ACDC::ALLOC_INDEX
*
* :SIMULATION_CHANGED
*    ACDC::CIRCUIT_CHANGE
*    GET_LOCAL_TIME   ==>_*nTime
* ;
*
* !!!END-INTERACT

xU1 3 11  VoltmeterU1

.subckt voltmeterU1 1 2
R1 1 2 1e6
.ends

*## Multisim Component R4 ##*
rR4 12 0 348 vresR4  
.model vresR4 r(  )

*## Multisim Component R3 ##*
rR3 9 0 348 vresR3  
.model vresR3 r(  )

*## Multisim Component R2 ##*
rR2 1 10 348 vresR2  
.model vresR2 r(  )

*## Multisim Component R1 ##*
rR1 1 2 348 vresR1  
.model vresR1 r(  )

*## Multisim Component V1 ##*
vV1 1 0 dc 5 ac 0 0
+           distof1 0 0
+           distof2 0 0


.SUBCKT TIL_RCV__NON__1 1 2
* TIL Receiver Model  1 = input, 2 = A/D out
 aADCin1 [1] [2] ADC
.MODEL ADC adc_bridge (in_low= 2.5 in_high = 2.5)
.ENDS

.subckt ADC8__ADC_DAC__1 vin vref+ vref- F0d F1d F2d F3d F4d F5d F6d F7d clk eoc PARAMS: conversion_time=1u
xU3 clk EOC_clk ONESHOT PARAMS: pulse_width={conversion_time}
a2 EOC_clk eoc DELAY
.model DELAY d_delay(rise_delay=2n fall_delay=2n)

a1 Vin [F0 F1 F2 F3 F4 F5 F6 F7]  Vref+ Vref- ADC_core

**FFs
ab0 F0 ~EOC_clk DGND DGND F0d 100 FF
ab1 F1 ~EOC_clk DGND DGND F1d 101 FF
ab2 F2 ~EOC_clk DGND DGND F2d 102 FF
ab3 F3 ~EOC_clk DGND DGND F3d 103 FF
ab4 F4 ~EOC_clk DGND DGND F4d 104 FF
ab5 F5 ~EOC_clk DGND DGND F5d 105 FF
ab6 F6 ~EOC_clk DGND DGND F6d 106 FF
ab7 F7 ~EOC_clk DGND DGND F7d 107 FF

.MODEL ADC_core ew_nla2d( )
.MODEL FF d_dff(clk_delay=1n set_delay=1n reset_delay=1n ic=0 rise_delay=1n fall_delay=1n)


.subckt ONESHOT in out PARAMS: pulse_width=100n
aU8 in 4 DIGITAL_DELAY
aU7 4 2 NOT
aU6  [4 2] 9 AND2
aU5 in 1 NOT
aU3  [in 1] 6 AND2
aU2 U2_OPEN_S U2_OPEN_R U2_OPEN_CLK 6 9 out U2_OPEN_notQ SR_FF
.MODEL SR_FF d_SRff (clk_delay = 1n set_delay = 1n reset_delay= 1n ic = 0 rise_delay = 1n fall_delay = 1n)
.MODEL AND2 d_and ( rise_delay = 1n fall_delay = 1n)
.MODEL NOT d_inverter (rise_delay = 10n fall_delay = 10n)
.model DIGITAL_DELAY d_delay (rise_delay={pulse_width} fall_delay={pulse_width} delay_type="transport")
.ends
     .ends


* Allow simulation of an otherwise all digital circuit
v_dummy_alg_source v_dummy_alg_net_name 0 dc 0 ac 0 0
